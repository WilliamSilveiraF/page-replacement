
#include <iostream>
#include <unordered_set>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

class PhysicalMemory {
private:
    unordered_set<int> pages;
    size_t capacity;

public:
    PhysicalMemory(size_t cap): capacity(cap) {}

    bool contains(int page) {
        return pages.find(page) != pages.end();
    }

    bool isFull() {
        return pages.size() == capacity;
    }

    void addPage(int page) {
        if(pages.size() < capacity) {
            pages.insert(page);
        }
    }

    void removePage(int page) {
        pages.erase(page);
    }

    size_t getCapacity() {
        return capacity;
    }
};

class Queue {
private:
    std::queue<int> q;

public:
    void enqueue(int page) {
        q.push(page);
    }

    int dequeue() {
        int front = q.front();
        q.pop();
        return front;
    }

    bool isEmpty() {
        return q.empty();
    }
};

class PageReplacementAlgorithm {
protected:
    PhysicalMemory memory;

public:
    PageReplacementAlgorithm(size_t cap): memory(cap) {}
    virtual int getPageFaults(int pages[], int n) = 0;
};

class FIFO : public PageReplacementAlgorithm {
private:
    Queue pagesQueue;

public:
    FIFO(size_t cap): PageReplacementAlgorithm(cap) {}

    int getPageFaults(int pages[], int n) override {
        int page_faults = 0;
        for (int i = 0; i < n; i++) {
            if (!memory.contains(pages[i])) {
                if (memory.isFull()) {
                    int oldestPage = pagesQueue.dequeue();
                    memory.removePage(oldestPage);
                }
                memory.addPage(pages[i]);
                pagesQueue.enqueue(pages[i]);
                page_faults++;
            }
        }
        return page_faults;
    }
};

class OPR : public PageReplacementAlgorithm {
public:
    OPR(size_t cap): PageReplacementAlgorithm(cap) {}

    int predict(int pg[], vector<int>& fr, int pn, int index) {
        int res = -1, farthest = index;
        for (size_t i = 0; i < fr.size(); i++) {
            int j;
            for (j = index; j < pn; j++) {
                if (fr[i] == pg[j]) {
                    if (j > farthest) {
                        farthest = j;
                        res = i;
                    }
                    break;
                }
            }
            if (j == pn)
                return i;
        }
        return (res == -1) ? 0 : res;
    }

    int getPageFaults(int pages[], int n) override {
        vector<int> fr;
        int page_faults = 0;
        for (int i = 0; i < n; i++) {
            if(find(fr.begin(), fr.end(), pages[i]) != fr.end()) {
                continue;
            }
            if (fr.size() < memory.getCapacity()) {
                fr.push_back(pages[i]);
            } else {
                int j = predict(pages, fr, n, i + 1);
                fr[j] = pages[i];
            }
            page_faults++;
        }
        return page_faults;
    }
};

class Manager {
private:
    FIFO fifo;
    OPR opr;

public:
    Manager(size_t cap): fifo(cap), opr(cap) {}

    void executeFifo(int pages[], int n) {
        cout << "Page Faults using FIFO: " << fifo.getPageFaults(pages, n) << endl;
    }

    void executeOPR(int pages[], int n) {
        cout << "Page Faults using OPR: " << opr.getPageFaults(pages, n) << endl;
    }
};

int main() {
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
    Manager manager(4);
    manager.executeFifo(pages, sizeof(pages)/sizeof(pages[0]));
    manager.executeOPR(pages, sizeof(pages)/sizeof(pages[0]));
    return 0;
}
